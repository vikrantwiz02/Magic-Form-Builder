import { useState } from 'react'
import { FormField, Condition, FormSettings, FieldType, ConditionOperator } from '../types/form'
import { Button } from "@/components/ui/button"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ClipboardIcon } from 'lucide-react'

interface CodeGeneratorProps {
  fields: FormField[]
  conditions: Condition[]
  formSettings: FormSettings
}

const LANGUAGES = [
  { value: "html-css", label: "HTML + CSS + JS" },
]

export default function CodeGenerator({ fields, conditions, formSettings }: CodeGeneratorProps) {
  const [language, setLanguage] = useState(LANGUAGES[0].value)
  const [copied, setCopied] = useState(false)

  const generateCode = () => {
    switch (language) {
      case 'html-css':
        return generateHtmlCssCode(fields, conditions, formSettings)
      default:
        return 'Unsupported language'
    }
  }

  const copyCode = () => {
    navigator.clipboard.writeText(generateCode())
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Generate Code</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div>
            <Select value={language} onValueChange={setLanguage}>
              <SelectTrigger>
                <SelectValue placeholder="Select Language/Framework" />
              </SelectTrigger>
              <SelectContent>
                {LANGUAGES.map(l => (
                  <SelectItem key={l.value} value={l.value}>{l.label}</SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          <div className="relative">
            <pre className="bg-gray-100 p-4 rounded-lg overflow-x-auto text-xs text-gray-800 max-h-96">
              <code>{generateCode()}</code>
            </pre>
            <Button
              className="absolute top-2 right-2"
              size="icon"
              onClick={copyCode}
            >
              <ClipboardIcon className="h-4 w-4" />
            </Button>
          </div>
          {copied && <p className="text-green-500 text-sm">Copied to clipboard!</p>}
        </div>
      </CardContent>
    </Card>
  )
}

// --- React + Tailwind Generator ---
function generateReactTailwindCode(fields: FormField[], conditions: Condition[], formSettings: FormSettings): string {
  return `
// Generated by Magic Form Builder
import React, { useState, useEffect } from "react";

const initialVisibleFields = ${JSON.stringify(fields.map(f => f.id))};

function evaluateCondition(formData, condition) {
  const value = formData[condition.fieldId];
  switch (condition.operator) {
    case "${ConditionOperator.Equals}": return value === condition.value;
    case "${ConditionOperator.NotEquals}": return value !== condition.value;
    case "${ConditionOperator.Contains}": return (value || "").includes(condition.value);
    case "${ConditionOperator.NotContains}": return !(value || "").includes(condition.value);
    case "${ConditionOperator.GreaterThan}": return value > condition.value;
    case "${ConditionOperator.LessThan}": return value < condition.value;
    case "${ConditionOperator.IsEmpty}": return !value;
    case "${ConditionOperator.IsNotEmpty}": return !!value;
    default: return false;
  }
}

export default function GeneratedForm() {
  const [formData, setFormData] = useState({});
  const [visibleFields, setVisibleFields] = useState(initialVisibleFields);
  const [errors, setErrors] = useState({});
  const [submitted, setSubmitted] = useState(false);

  useEffect(() => {
    // Advanced: handle multiple, nested, and conflicting conditions
    let newVisible = [...initialVisibleFields];
    ${conditions.length > 0 ? `
    ${conditions.map((c, i) => `
    if (evaluateCondition(formData, ${JSON.stringify(c)})) {
      if ("${c.action}" === "show" && !newVisible.includes("${c.targetFieldId}")) newVisible.push("${c.targetFieldId}");
      if ("${c.action}" === "hide" && newVisible.includes("${c.targetFieldId}")) newVisible = newVisible.filter(f => f !== "${c.targetFieldId}");
    }
    `).join('\n')}
    ` : ''}
    setVisibleFields([...new Set(newVisible)]);
  }, [formData]);

  const handleInputChange = (e) => {
    const { name, value, type, checked, files } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === "checkbox" ? checked : (type === "file" ? files[0] : value)
    }));
  };

  const validate = () => {
    const newErrors = {};
    ${fields.map(f => `
    if (${f.required ? `visibleFields.includes("${f.id}") && !formData["${f.id}"]` : "false"}) {
      newErrors["${f.id}"] = "This field is required";
    }
    `).join('\n')}
    return newErrors;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    const errs = validate();
    setErrors(errs);
    if (Object.keys(errs).length === 0) {
      setSubmitted(true);
      // Do something with formData
      console.log(formData);
    }
  };

  if (submitted) {
    return <div className="text-center p-8 text-green-600 text-xl">${formSettings.successMessage}</div>;
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4 max-w-xl mx-auto bg-white p-6 rounded shadow">
      <h2 className="text-2xl font-bold mb-4">${formSettings.title}</h2>
      ${formSettings.description ? `<p className="mb-6 text-gray-600">${formSettings.description}</p>` : ""}
      {visibleFields.map(fid => {
        switch(fid) {
          ${fields.map(f => `
          case "${f.id}":
            return (
              <div key="${f.id}" className="space-y-2">
                <label htmlFor="${f.id}" className="block font-medium">
                  ${f.label}${f.required ? ' <span className="text-red-500">*</span>' : ''}
                </label>
                ${renderReactField(f)}
                {errors["${f.id}"] && <div className="text-red-500 text-xs">{errors["${f.id}"]}</div>}
              </div>
            );
          `).join('\n')}
          default: return null;
        }
      })}
      <button type="submit" className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">${formSettings.submitButtonText}</button>
    </form>
  );
}

// --- Field Renderers ---
${renderReactFieldHelpers(fields)}
`.trim();
}

function renderReactField(field: FormField): string {
  switch (field.type) {
    case FieldType.Text:
      return `<input
        type="text"
        id="${field.id}"
        name="${field.id}"
        value={formData["${field.id}"] || ""}
        onChange={handleInputChange}
        className="w-full border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 transition"
        aria-invalid={!!errors["${field.id}"]}
        aria-describedby="${field.id}-error"
      />`
    case FieldType.TextArea:
      return `<textarea
        id="${field.id}"
        name="${field.id}"
        value={formData["${field.id}"] || ""}
        onChange={handleInputChange}
        className="w-full border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 transition"
        aria-invalid={!!errors["${field.id}"]}
        aria-describedby="${field.id}-error"
      />`
    case FieldType.Checkbox:
      return `<input
        type="checkbox"
        id="${field.id}"
        name="${field.id}"
        checked={!!formData["${field.id}"]}
        onChange={handleInputChange}
        className="h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
        aria-invalid={!!errors["${field.id}"]}
        aria-describedby="${field.id}-error"
      />`
    case FieldType.Radio:
      return `
        <div className="flex flex-wrap gap-4">
          ${(field.options || []).map((opt, i) =>
            `<label key={${i}} className="inline-flex items-center gap-2 cursor-pointer">
              <input
                type="radio"
                name="${field.id}"
                value="${opt}"
                checked={formData["${field.id}"] === "${opt}"}
                onChange={handleInputChange}
                className="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500"
                aria-invalid={!!errors["${field.id}"]}
                aria-describedby="${field.id}-error"
              />
              <span>${opt}</span>
            </label>`
          ).join('\n')}
        </div>
      `
    case FieldType.Select:
      return `
        <select
          id="${field.id}"
          name="${field.id}"
          value={formData["${field.id}"] || ""}
          onChange={handleInputChange}
          className="w-full border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 transition"
          aria-invalid={!!errors["${field.id}"]}
          aria-describedby="${field.id}-error"
        >
          <option value="">Select an option</option>
          ${(field.options || []).map(opt => `<option value="${opt}">${opt}</option>`).join('\n')}
        </select>
      `
    case FieldType.File:
      return `<input
        type="file"
        id="${field.id}"
        name="${field.id}"
        onChange={handleInputChange}
        className="block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-gray-50 focus:outline-none"
        aria-invalid={!!errors["${field.id}"]}
        aria-describedby="${field.id}-error"
      />`
    case FieldType.Rating:
      return `
        <div className="flex items-center space-x-1">
          {[...Array(${field.maxRating || 5})].map((_, i) => (
            <button
              key={i}
              type="button"
              className={\`text-2xl transition \${i < (formData["${field.id}"] || 0) ? "text-yellow-400" : "text-gray-300"} hover:scale-125\`}
              onClick={() => setFormData(prev => ({ ...prev, "${field.id}": i + 1 }))}
              aria-label={\`Rate \${i + 1}\`}
            >★</button>
          ))}
        </div>
      `
    case FieldType.Integer:
      return `<input
        type="number"
        id="${field.id}"
        name="${field.id}"
        value={formData["${field.id}"] || ""}
        onChange={handleInputChange}
        min={${field.min ?? 0}}
        max={${field.max ?? 100}}
        className="w-full border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 transition"
        aria-invalid={!!errors["${field.id}"]}
        aria-describedby="${field.id}-error"
      />`
    case FieldType.Date:
      return `<input
        type="date"
        id="${field.id}"
        name="${field.id}"
        value={formData["${field.id}"] || ""}
        onChange={handleInputChange}
        className="w-full border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 transition"
        aria-invalid={!!errors["${field.id}"]}
        aria-describedby="${field.id}-error"
      />`
    default:
      return ""
  }
}

function renderReactFieldHelpers(fields: FormField[]): string {
  // For extensibility: add custom hooks, helpers, etc.
  return `// Add custom hooks or helpers here if needed`
}

// --- HTML + CSS + JS Generator ---
function generateHtmlCssCode(fields: FormField[], conditions: Condition[], formSettings: FormSettings): string {
  const htmlCssStyle = `
    body { font-family: 'Inter', Arial, sans-serif; background: #f4f4f4; padding: 20px; }
    form { max-width: 500px; margin: 0 auto; background: #fff; padding: 24px; border-radius: 12px; box-shadow: 0 2px 16px #0002; }
    .form-group { margin-bottom: 22px; }
    label { display: block; margin-bottom: 7px; font-weight: 600; color: #22223b; }
    .input, select, textarea { width: 100%; padding: 10px 12px; border: 1.5px solid #c9c9c9; border-radius: 8px; font-size: 1rem; transition: border 0.2s; }
    .input:focus, select:focus, textarea:focus { border-color: #6366f1; outline: none; box-shadow: 0 0 0 2px #6366f133; }
    .checkbox, .radio { accent-color: #6366f1; }
    .radio-label { margin-right: 18px; font-weight: 500; }
    .error { color: #e53e3e; font-size: 0.93em; margin-top: 2px; }
    .rating { display: flex; gap: 4px; }
    .star { display: none; }
    .star-label { font-size: 1.7em; color: #c9c9c9; cursor: pointer; transition: color 0.2s, transform 0.2s; }
    .star:checked ~ .star-label, .star-label:hover, .star-label:hover ~ .star-label { color: #f6c700; transform: scale(1.2); }
    button { background: #6366f1; color: #fff; padding: 12px 22px; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: background 0.2s; }
    button:hover { background: #3730a3; }
    .hidden { display: none; }
  `;
  return `
<!-- Generated by Magic Form Builder -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${formSettings.title}</title>
  <style>
    ${htmlCssStyle}
  </style>
</head>
<body>
  <form id="generatedForm" novalidate>
    <h2>${formSettings.title}</h2>
    ${formSettings.description ? `<p>${formSettings.description}</p>` : ""}
    ${fields.map(field => `
    <div class="form-group" id="${field.id}-container">
      <label for="${field.id}">${field.label}${field.required ? ' <span style="color: red;">*</span>' : ''}</label>
      ${renderHtmlField(field)}
      <div class="error" id="${field.id}-error"></div>
    </div>
    `).join('\n')}
    <button type="submit">${formSettings.submitButtonText}</button>
  </form>
  <script>
    const form = document.getElementById('generatedForm');
    const formData = {};
    let visibleFields = ${JSON.stringify(fields.map(f => f.id))};

    function evaluateCondition(formData, condition) {
      const value = formData[condition.fieldId];
      switch (condition.operator) {
        case "${ConditionOperator.Equals}": return value === condition.value;
        case "${ConditionOperator.NotEquals}": return value !== condition.value;
        case "${ConditionOperator.Contains}": return (value || "").includes(condition.value);
        case "${ConditionOperator.NotContains}": return !(value || "").includes(condition.value);
        case "${ConditionOperator.GreaterThan}": return value > condition.value;
        case "${ConditionOperator.LessThan}": return value < condition.value;
        case "${ConditionOperator.IsEmpty}": return !value;
        case "${ConditionOperator.IsNotEmpty}": return !!value;
        default: return false;
      }
    }

    function updateVisibleFields() {
      let newVisible = [...visibleFields];
      ${conditions.map(c => `
      if (evaluateCondition(formData, ${JSON.stringify(c)})) {
        const container = document.getElementById('${c.targetFieldId}-container');
        if ("${c.action}" === "show") {
          container.classList.remove("hidden");
          if (!newVisible.includes("${c.targetFieldId}")) newVisible.push("${c.targetFieldId}");
        } else if ("${c.action}" === "hide") {
          container.classList.add("hidden");
          newVisible = newVisible.filter(f => f !== "${c.targetFieldId}");
        }
      }
      `).join('\n')}
      visibleFields = Array.from(new Set(newVisible));
    }

    form.addEventListener('input', function(event) {
      const { name, value, type, checked, files } = event.target;
      formData[name] = type === "checkbox" ? checked : (type === "file" ? files[0] : value);
      updateVisibleFields();
    });

    form.addEventListener('submit', function(event) {
      event.preventDefault();
      let valid = true;
      ${fields.map(f => `
      if (${f.required ? `visibleFields.includes("${f.id}") && !formData["${f.id}"]` : "false"}) {
        document.getElementById("${f.id}-error").textContent = "This field is required";
        valid = false;
      } else {
        document.getElementById("${f.id}-error").textContent = "";
      }
      `).join('\n')}
      if (valid) {
        form.innerHTML = '<div style="text-align: center; color: #16a34a; font-size: 1.2em; padding: 2em 0;">${formSettings.successMessage}</div>';
      }
    });

    // Initial visibility update
    updateVisibleFields();
  </script>
</body>
</html>
`.trim();
}

function renderHtmlField(field: FormField): string {
  switch (field.type) {
    case FieldType.Text:
      return `<input type="text" id="${field.id}" name="${field.id}" class="input" ${field.required ? 'required' : ''} />`
    case FieldType.TextArea:
      return `<textarea id="${field.id}" name="${field.id}" class="input" ${field.required ? 'required' : ''}></textarea>`
    case FieldType.Checkbox:
      return `<input type="checkbox" id="${field.id}" name="${field.id}" class="checkbox" ${field.required ? 'required' : ''} />`
    case FieldType.Radio:
      return (field.options || []).map((opt, i) => `
        <label class="radio-label">
          <input type="radio" id="${field.id}-${i}" name="${field.id}" value="${opt}" class="radio" ${field.required ? 'required' : ''} />
          ${opt}
        </label>
      `).join('\n')
    case FieldType.Select:
      return `
        <select id="${field.id}" name="${field.id}" class="input" ${field.required ? 'required' : ''}>
          <option value="">Select an option</option>
          ${(field.options || []).map(opt => `<option value="${opt}">${opt}</option>`).join('\n')}
        </select>
      `
    case FieldType.File:
      return `<input type="file" id="${field.id}" name="${field.id}" class="input" ${field.required ? 'required' : ''} />`
    case FieldType.Rating:
      return `
        <div class="rating">
          ${[...Array(field.maxRating || 5)].map((_, i) => `
            <input type="radio" id="${field.id}-${i + 1}" name="${field.id}" value="${i + 1}" class="star" ${field.required ? 'required' : ''} />
            <label for="${field.id}-${i + 1}" class="star-label">★</label>
          `).join('\n')}
        </div>
      `
    case FieldType.Integer:
      return `<input type="number" id="${field.id}" name="${field.id}" min="${field.min ?? 0}" max="${field.max ?? 100}" class="input" ${field.required ? 'required' : ''} />`
    case FieldType.Date:
      return `<input type="date" id="${field.id}" name="${field.id}" class="input" ${field.required ? 'required' : ''} />`
    default:
      return ''
  }
}